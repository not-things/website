This article covers the basics of C++ templates. I originally wrote this for a friend that was new to C++.

* Rationale and use
Templates are used for generic programming. That means that you don't care about what the type of the data is, only the algorithms that operate on them. A well known example is the C++ container library, where classes like ~std::vector~ lets you create a dynamic array to store any object.

It allows for code reuse 

* Example

We want a simple array that also stores its size. We might want to resize it later.  In C, you'll need to specify the type of the data that the array will store beforehand[fn:1]. So it might look something like this.

#+begin_src C
struct MyArray {
	int store[];
	int size;
};
#+end_src

However, you'll need to specify

It's easier to keep everything relevant in a struct/class than having separate classes for them.

We want to be able to write code with parameters that we'll fill in later when we actually instantiate an object. 

#+begin_src c++

#include <array>
#include <iostream>

template<typename T>
class MyTemplatedArray {
    T store[10];
    int size = 10;
};

int main() {
    // This is basically a wrapper around a 'C-style' array
    std::array<int, 10> int_array;
    // So under the hood it would be something like this
    int c_style_array[10];
    // Except that there are convenience functions built into the class
    // For example you can check the size of the array
    std::cout << "Array size is: " << int_array.size() << "\n";

    // You can store different types in the array.
    std::array<char, 30> char_array;
    std::array<long, 20> long_array;
    // You can even store arrays of arrays
    std::array<std::array<int, 10>, 10> array_array;

    // Container types (classes that contain other objects) like
    // std::array are a very powerful programming paradigm in C++.
    // You can store objects of **any type** and still be able
    // to access all of the convenience functions. Contrast it with 
    // 'C-style' arrays. The equivalent in C would be much more difficult
    // or verbose. For example, to get the size of an array, you'd need
    // to first make your own class in order to store the size.

    struct MyArrayInt {
        int store[10];
        int size = 10; // Or create a function that returns this value
    };

    // Another problem arises when you want to store different types
    // of objects. In C, you'd need to define a struct for every single
    // type of object that you plan on using

    struct MyArrayChar {
        char store[10];
        int size = 10;
    };

    struct MyArrayLong {
        long store[10];
        int size = 10;
    };

    // An alternative is to use void*. This essentially tells the 
    // compiler that you don't care about what type of object
    // is being stored at the pointer. 

    struct MyGenericArray {
        void* store;
        int size = 10;
    };

    MyGenericArray arr;
    // Let's say that I want to store 10 integers in this array.
    arr.store = malloc(sizeof(int) * 10);

    // And you access elements like so:
    int fifth_element = ((int*)arr.store)[4];
    //                   ^- First we need to cast it to an int pointer
    //                      otherwise the compiler doesn't know 
    //                      what we're accessing

    // However, this can cause issues, especially if you accidentally 
    // mess up the casting of the type.
    // For example, this will be *undefined behavior* in C++:
    // long fifth_element = ((long*)arr.store)[4];

    // This is known as 'type safety' in progamming languages.
    // In a type-safe language, you cannot access an object
    // as-if it was different incompatible type. C is not type-safe when
    // you use void pointers.

    // There are other issues with void pointers,
    // but I will omit them for brevity.

    // In C++, templates are used to solve this problem.
    std::array<int, 20> type_safe_array;
    // You specify the type and size of the array, and the object
    // will always have that type and that size.

    // The class declaration for std::array might look something
    // like the MyTemplatedArray class declaration at the top of this file
    // (It would only be able to store 10 items while the real std::array
    // can specifiy an arbitrary number, but I'm simplifying for brevity.)
    
    // Notice the template<typename T> declaration at the top.
    // This tells the compiler that you can declaring a templated class.
    // the T is a placeholder type - you don't know what will be the
    // actual type until you actually write the code to use it.
    
    // Then you can instantiate the class like so:
    MyTemplatedArray<int> custom_int_array;
    // During compilation, code is generated to make an object
    // that lives here. It is at this time that the placeholder type
    // is set - since we specified that we wanted an int array,
    // the compiler will essentially replace all instances where 'T'
    // appears with an 'int'. So that templated array would look
    // something like this at the end:
    class MyIntTemplatedArray {
        int store[10];
        int size = 10;
    };

    // This is done for every single type that the compiler sees.
    // For example: 
    MyTemplatedArray<long> custom_long_array;
    MyTemplatedArray<char> custom_char_array;
    // Generates classes with long and char arrays.

    // This allows you to create classes that operate on objects
    // for any custom type that you can think of.
    MyTemplatedArray<MyTemplatedArray<int>> custom_array_array;
    // This would make an array of array of integers.

    // This style of programming is often referred to as 
    // 'generic programming'. You don't really care about what the 
    // underlying data is, but rather the algorithms that operate
    // on the data.

    // In my opinion, it's one of strongest features of C++. 
    // It might not be particularly useful for small classes like this,
    // but with large classes you're able
    // to avoid code duplication while still being able to write
    // functions that operate on a wide range of types.
}

#+end_src



* 

* Footnotes

[fn:1] There are techniques to simulate generic types with macros in C, but that's out of the scope of this article. For more information, see [[https://codereview.stackexchange.com/questions/274860/concept-of-implementing-generic-types-in-c-using-macros][this]] post.

